//Raymond@HZHL3 ~/code/eclipse/scribble/github.com/rumineykova/scribble-java
//$ bin/scribblec-assrt.sh -ip scribble-assertions/src/test/scrib/ -d scribble-assertions/src/test/scrib/ scribble-assertions/src/test/scrib/assrt/tmp/AssrtCoreTest.scr -Z3 -ass Proto1 -V 


// http://sandbox.kidstrythisathome.com/erdos/




// FIXME: debug printing for assertion passes

// FIXME: distinguish branches where "not guaranteed safe" vs "impossible"



// unary choice: 
//   pre: forall (lhs)
//   forall lhs => (exists rhs) -- point is rhs may use vars in lhs
//   exists (lhs /\ rhs)
// -- forall [ (lhs /\ (lhs => (exists rhs))) => exists (lhs /\ rhs) ] -- ?
// -- forall [ lhs /\ (lhs => (exists rhs))) ] => forall [ exists (lhs /\ rhs) ] -- ?
/*
(declare-fun lhs (Int Int) Bool)
(declare-fun rhs (Int Int Int Int) Bool)
(assert (forall ((x1 Int) (y1 Int)) (lhs x1 y1)))
(assert  (=>   
  (forall ((x1 Int) (y1 Int)) (and (lhs x1 y1) (=> (lhs x1 y1) (exists ((x2 Int) (y2 Int)) (rhs x1 y1 x2 y2)))))
  (forall ((x1 Int) (y1 Int)) (exists ((x2 Int) (y2 Int)) (and (lhs x1 y1) (rhs x1 y1 x2 y2))))
))
(check-sat)  // FIXME: check negation is unsat
(exit)  
*/


// FIXME: statevar decl invariants
// muZ for fixed points -- recursive statevar updates? -- http://rise4fun.com/Z3/tutorial/fixedpoints

// - assertion validation
// - receive assertions -- why receive assertions?  should WF imply receive assertions always true?
// - explicit connections

// .. checking assertions sender side only is important for services -- maybe complex/expensive operation, point is to ask service to do it, so must be the service only to check it also

//	.. rename connect to request
//	.. refactor a GConnectionAction (cf. LConnectionAction)

// .. need to update SubprotocolSig and "cycle" detection for protocoldecl/do annots? -- protocol inlining/unfolding with annots/assertions
// .. how about "syntactic" reachability check with protocoldecl/do annots?

// - recursion annotations
// - port forwarding annotations/assertions
// - arrays? -- cf. dependent types for array/list lengths -- https://www.reddit.com/r/fsharp/comments/28bbsr/faking_dependent_types_in_f/

// redo inlining/unfolding via model building? role/param/assert all in model states?

// FIXME: batching optimisation contains redundancy? -- all formulae are standalone (full "trace histories"), but maybe not necessary if batching?




// unsat is a preserving safety error, op sem should freeze on an unsat choice -- but otherwise should allow branch selection, even if not "strictly" assert-prog
// assert-prog is a progress guarantee, but not a preserving safety error -- because assert-prog says there isn't a guaranteed option to proceed, but by op sem we can take any non-unsat case anyway

// try: simply compact all clauses with old vars -- since old var value is "lost", can never eval the clause anyway? -- model corresponds to the way syntactic var substitution works?
//		more explicitly, it corresponds to a scoping mechanism derived from syntactic source protocol that determines what vars can be "used" as constraints at protocol points?
// or continue-specific ("statevar update" of action) GC of clauses with old vars?

// F is a set of constraints that are true so far, but need to record to check more upcoming constraints
// once any clause has an "old var", can delete the clause because model is that we don't have old var value anymore so can't evaluate the constraint
// arguing about the "value" doesn't really make sense here, because doing forall anyway
// it's more like, "old var" ever won't be "used" in an upcoming constraint -- at least not "directly", but also not "indirectly"? -- also not "indrectly" because of "temporal ordering" given by syntax: e.g., x->y->z->loop, if x becomes old, then any upcoming use of y must also occur after y becomes old




module assrt.tmp.AssrtCoreTest;


type <dotnet> "System.UInt32" from "..." as int;
type <dotnet> "System.String" from "..." as str;

/*
- model checking: uniform validation for integrating different MPST features
- assertions only "reduce" behaviours? true-only assertions
- basic model based on "types" -- so 1-bounded finite
- how to introduce semantics of assertions into model and stay finite?
-- because assertions introduce values -- arithmetic
- have to leverage syntactic characteristics to support the model checking
-- all about recursion (including action assertions, not only statevars), managing finiteness
-- assertions as syntactic terms (syntactically equal terms have same meaning), CNF sets allows "syntactic"-closure on constraints -- no hardcoded two-unfolding
-- "old actvar" renaming for recursively "shadowed" vars -- following syntactic recursion substitution -- cf. fresh vars
--- multiparty old actvar renaming based on message flow
--- then compacting -- i.e., syntactic term GC hack
-- then the "inductive" step, given by old statvar renaming becoming forall
--- very conserative -- restore "precision" by recursion assertions as "loop invariants"
- so model checked errors: unknownvar (HS), assert-prog (TS?), sat (TS?), recursion-assert
*/


global protocol Proto1(role A, role B)
{
	1(x:int) from A to B;
	2(y:int) from B to A;  @"f(x)"
}


/*
global protocol Proto1(role A, role B, role C) {
	choice at A
	{
		1() from A to B; @"A1"
		1() from A to C;           // CHECKME: receiver-side ass not projected -- but if it were, would need A1
	}
	or
	{
		...
	}
}
//*/


/*
global protocol SH(role P, role R, role C) {
	plane(x1:int, x2:int, x3:int, x4:int) from P to R;
	do Loop(P, R, C);
}

global protocol Loop(role P, role R, role C) {
	choice at P {
		Above(v1:int) from P to R;   
		Res(b1:int) from R to P;  @"b1=0 || b1=1"
		Above(v2:int) from P to R;   
		Res(b2:int) from R to P;  @"b2=0 || b2=1"
		choice at P {
				BothIn() from P to R;  @"b1=1 && b2=1"
				BothIn(r1:int) from P to C;
				do Loop(P, R, C);  // Recursion
			} or {
				BothOut() from P to R;  @"b1=0 && b2=0"
				BothOut() from P to C;
				do Loop(P, R, C);  // Recursion
		} or {
			Intersect() from P to R;  @"(b1=1 && b2=0) || (b1=0 && b2=1)"
			Res(i:int) from R to P;
			choice at P {
				One(r2:int) from P to C;   @"b2=0 && r2=i"
				do Loop(P, R, C);  // Recursion
			} or {
				Two(r3:int, r4:int) from P to C;  @"b2=1 && (r3=i && r4=v2)"
				do Loop(P, R, C);  // Recursion
		} }
	} or {
		Close() from P to R;   
		Close() from P to C;  // End
	}
}
//*/


/*
global protocol SH(role P, role R, role C) {
	plane(x1:int, x2:int, x3:int, x4:int) from P to R;
	rec Loop {
		choice at P {
			check(p1:int, p2:int) from P to R;
			PointsToForward(res:int) from R to P; @"res>=0 && res<=2"
			choice at R {
				noIntersection() from R to P; @"res=1"
				OnePoint(v1:int) from P to C; @"v1=p2"
				continue Loop;
			} or {
				noPoints() from R to P; @"res=0"
				noPoints() from P to C;
				continue Loop; 
			} or {
				intersection(p3:int) from R to P; @"res=1 || res=2"
				choice at P {
					OnePointb(v2:int) from P to C; @"res=1 && v2=p3"
					continue Loop;
				} or {
					TwoPoint(v3:int, v4:int) from P to C; @"res=2 && (v3=p3 && v4=p2)"
					continue Loop;
				}
			}
		} or {
			Close() from P to R;
			Close() from P to C;
		}
	}
}
//*/



/*
global protocol Proto1(role A, role B)
{
	//1(x:int, y:int) from A to B;  @"x>3 && y>4"  // OK

	/*1(x:int, y:int) from A to B;  @"x=y"  // OK
	2() from B to A;  @"x=y"* /

	1(x:int, y:int) from A to B;
	2() from B to A;  @"x=y"  // Bad
}
//*/












/*
..demo:
- model building: model state extensions for assertions
-- assert-prog vs. sat -- DbC assert-prog choice case disjunction
-- bounded model with recursion (1): actvar renaming ("oldvar" GC) -- leveraging syntactic unfolding "semantics" of recursion
-- async MP: renaming following message flows
- statevars
-- bounded model with recursion (2): conservative forall on old statevars
-- "same var" special case
-- statevar invariants -- statevar-assert-prog
- uninterpreted funs
-- domain-specific theories (e.g., open/port)
-- encode roles/etc as ints
-- domain-specific API gen

global protocol Proto1(role A, role B)
{
	1(x:int) from A to B;  @"x>3"
	
	choice at B
	{
		2() from B to A;  @"x<0"
		4() from B to A;  @"False"
	}	
	or
	{
		3() from B to A;  @"True"
	}	
}
//*/


























/*
global protocol Proto1a(role A, role B)  @"(x:=1)"
{
	1(x:int) from A to B;	
	2(y:int) from B to A;	 @"y>x"

	do Proto1a(A, B);  @"<x+1>"
}

global protocol Proto1b(role A, role B)
{
	1() from A to B;	
	2(y:int) from B to A;	 @"y>x"
}

global protocol Proto1c(role A, role B)
{
	1() from A to B;	     @"x>3"
	2(y:int) from B to A;	 @"y>x"
}

global protocol Proto1d(role A, role B, role C)
{
	1(x:int) from A to B;	 @"x>3"
	2(y:int) from B to C;	 @"y>x"  // y>x added to F(C), but x *not* added to F(C) -- N.B. x will be forall quantified at C, and x>3 *not* in F(C) 
	3(z:int) from C to A;	 @"z>x"
}

global protocol Proto1e(role A, role B, role C)
{
	1(x:int) from A to B;	 @"x>3"
	2(y:int) from B to C;	 @"y>x"
	3(z:int) from A to C;	 @"z>x"  // assertion not checked on receiver side
}

global protocol Proto1f(role A, role B, role C, role D)
{
	1(x1:int) from A to B;	@"x1=3"
	2(x2:int) from A to D;	@"x2=x1"

	3(y1:int) from B to C;	@"y1=x1"
	4(y2:int) from D to C;	@"y2=x2"
	
	5(z:int) from C to A;   @"z=y1 && z=y2"  // only adding "immediate" assertion to F is weak? can strengthen?
}
//*/












/*
global protocol Proto1(role A, role B)
{
	1(x:int) from A to B;  @"!(x<3)"
	2() from A to B;  @"(True && !(False))"

}
//*/

/*
global protocol Proto1(role A, role B)
{
	1() from A to B;
	do Proto2(A, B);
}

aux global protocol Proto2(role A, role B) @"2<3"  // FIXME: unknown vars check
{
	2() from A to B;
}
//*/

/*
global protocol Proto1(role A, role B) @"(x:=(1+(1-1)), y:=4)"
{
	1() from A to B; @ "(x<3 && x<3) || x<3+(1+2)"
	//@"(((x>1) && (x>2)) && (x>3))"
	//@"(((True)))"
	2() from B to A; @"foo()"  // FIXME: constants
	//2() from B to A; @"((((True))))"
	do Proto1(A, B);  @"<0, 0>"
}
//*/



// TOO try: mu X . ( A->B 1 . X + A->B 2 . mu Y . A->B 3 . Y ) with statevars and assertions

/*
global protocol Proto1(role A, role B)
		@"(x := 1) (x>0)"
		//@"(x := 0) (x>0)"
{
	//1(y:int) from A to B; @"(y>1)"
	1() from A to B;
}
//*/

/*
global protocol Proto1(role A, role B)
{
	//1(y:int) from A to B; @"(y>1)"
	1(y:int) from A to B; @"(y>3)"
	do Proto2(A, B); @"(y)"
}

aux global protocol Proto2(role A, role B) @"(x := 0) (x>2)"
{
	2() from B to A;
}
//*/

/*
global protocol Proto1(role A, role B)  @"(x := 1)"
{
	1(y:int) from A to B;  @"(y > x)"
	2() from B to A;
	do Proto1(A, B);  @"(x)"
}
//*/

/*
global protocol Proto1(role A, role B)  
		@"(x := 3) (x>2)"
		//@"(x := 3) (x>0)"
		//@"(x := 3) (x>1)"
{
	1() from A to B; @"(x>1)"
	//2() from B to A;
	//do Proto1(A, B);  @"(x)"  
			// CHECKME: no longer needs to be special case, given appropriate rec-assertion? -- but at least is an optimisation?
			// no: special case still different, no "old var" renaming (no "inductive unrolling")
	//do Proto1(A, B);  @"((x+1))"
	do Proto1(A, B);  @"((x-1))"
}
//*/

/*
//global protocol Proto1(role A, role B)  @"(x := 1)"
global protocol Proto1(role A, role B)  @"(x := 2) (x>1)"
//global protocol Proto1(role A, role B)  @"(x := 1) (y>0)"
{
	//1() from A to B;
	//1() from A to B; @"(x>0)"
	1() from A to B; @"(x>1)"
	2() from B to A;

	//do Proto1(A, B);  @"(x)"
	//do Proto1(A, B);  @"((x+1))"
	do Proto1(A, B);  @"((x-1))"
}
//*/

















// uninterpreted functions for custom API gen
// multi statvars -- fibo, linear
/*
global protocol Proto1(role A, role B) @"(x:=(0+3), y:=1)"
{
	1(z:int) from A to B;  @"(x>1)"
	do Proto1(A, B); @"(3, 1)"
}
//*/


/*
explicit global protocol Proto1(role A, role B, role C)
{
	connect A to B;
	1(lin x:int) from A to B; @port(x, C);  // implies port(x, C) and not(port(x, A)), not(port(x, B))
	
	rec X1 (used_x = 0) {

		1(z:int) from B to C; @(fw(x -> z) ... used_x =0); // implies port(x, C) and not(port(x, A)), not(port(x, B))
		
		rec X2 (used_x = 1) {

			1(z2:int) from B to C; @(... used_x = 0); // implies port(x, C) and not(port(x, A)), not(port(x, B))

			connect B to C;
			2(y:int) from B to A; @(x=y);

			connect C to A; @request(x, C);  // C should know x; should imply port(x, C);
		}
		}
} // terminal state needs all linear used
//*/


/*
global protocol Proto1(role A, role B)
{
	1(x:int) from A to B; 
	2(y:int) from B to A; @(x=y);
	3(z:int) from B to A; @(z=y);  // Should this be "linearity" error?
}
//*/


























/*/
global protocol Proto1(role A, role B) @(x=0);
{
	1() from A to B;
	do Proto2(A, B);
}

aux global protocol Proto2(role A, role B)
{
	2() from B to A; @(x<1);  // FIXME: shouldn't be in scope without decl as Proto2 statevar -- OK because aux? error caught if Proto2 checked as root
}
//*/

/*
global protocol Proto1(role B, role S)
{
	ok() from B to S;
	do Proto2(B, S); @Quote;  // FIXME: unknown vars check
}

global protocol Proto2(role B, role S) @(x=0);
{
	5() from B to S;	@False;//@(y>0);  // FIXME: unknown vars check here too?
}
//*/


/*
global protocol Proto1(role A, role B) @(z=3);
{
	1(x:int) from A to B; @(x=3);
	2(y:int) from A to B; @(y>x);
	do Proto1(A, B);  // FIXME: statevar arg check
}
//*/












/*
global protocol Proto1(role A, role B) @(x=3);
{
	1() from A to B; @(x>2);	
	do Proto2(A, B); @(x);  
			// FIXME: need to make expr vars old in F? -- proto shouldn't be valid?
			// could rename target y to x in this case? relies on "globally" (across subprotos) unique vars -- cf. rolename substitution
}

// Not aux
global protocol Proto2(role A, role B) @(y=4);
{
	1() from A to B; @(y>2);	
	do Proto1(A, B); @(y);
}
//*/

/*
global protocol Proto1(role A, role B)
{
	do Proto2(A, B); @1;  
			// FIXME: in this case, consider subsituting the x in Proto1<x+1> like DbC? but would be inconsistent generally?
			// FIXME: at least consider case for substituting x if syntactically just "x" and still just x -- cf. bad.extensions.assrtcore.safety.assrtprog.statevar.AssrtCoreTest08b
}

global protocol Proto2(role A, role B) @(x=1);
{
	1(y:int) from A to B; @((y=x) && (x=1));

	//do Proto1(A, B); @1;
	do Proto2(A, B); @(x+1);  
			// Unsat -- cf. DbC? -- OK there? but relies on two-unfolding cut off? 
			// No: DbC subs the x in X<x+1> fixing it to two at two unfoldings and forever after? that's why safe there
			
	// FIXME: check tests for "loop counting", e.g., X<x+1> -- and also with lower bounded ints (do bounds manually)
}
//*/

/*
global protocol Proto1(role A, role B) @(x=3);
{
	1() from A to B; @(x>2);	

	//do Proto1(A, B); @x;  // Currently unsat -- cf. DbC? -- DbC it wouldn't be "x", it would "already" be 3 from substitution
			// Note, Proto1 could be called from "any context", so x can really be anything
			// FIXME: make sat? treat single var formula as special case? cf. equality in "non-local" assertions vs. gt/lt

	//do Proto1(A, B); @(x+1);  // Unsat
	do Proto1(A, B); @(x-1);  // Unsat -- should be unsat
}
//*/

/*
global protocol Proto1(role A, role B)
{
	1(x:int) from A to B;
	do Proto2(A, B);
}

aux global protocol Proto2(role A, role B)
{
	2(x:int) from B to A;  // FIXME: need proper var shadowing
}
//*/
















// ---


/*
global protocol Proto1(role A, role B, role C)
{
	1(x:int) from A to B; @(x>3);
	2(y:int) from B to C; @(y>x);  // OK: B knows x

	//---

	1(x:int) from A to B; @(x>3);
	2() from B to C;
	3(y:int) from C to B; @(y>x);  // Bad: C doesn't know x -- though it knows x > 3 -- FIXME: how to disallow this? but still allow the below
			// CHECKME: DbC -- cf. HS
	
	//---	
	
	1(x:int) from A to B; @(x=3);  // FIXME: but equality should be strong enough?
	2() from B to C;
	3(y:int) from C to B; @(y>x);
}
//*/


/*
global protocol Proto1(role A, role B) @(z=0);
{
	1(x:int) from A to B; @(x>3);
	2(y:int) from B to C; @(y>x);  // C does *not* "know" x -- but knows constraints must be satisfied up to here
	3(z:int) from C to D; @(z>y);
	
//--- vs.

	1(x:int) from A to B; @(x=3);  // equality is "precise" enough for "strong path inference"
	2(y:int) from B to C; @(y>x);
	3(z:int) from C to D; @(z>y);
}
//*/


/*
global protocol Proto1(role A, role B, role C)
{
	1(x:int) from A to B; @(x>1);
	2(y:int) from B to C; @(y>x);

	//3(z:int) from C to A; @(z=y);  // OK
	3(z:int) from C to A; @((z=y)&&(y>x));  //  Morally same as above -- given C should know this from the "path" here
			// FIXME? C doesn't know x -- but could pass prev assertions along with current? cf. DbC projection (at receiver)
			// DbC projection vs. HS/TS? -- DbC receive-exists projection vs HS/TS "forall"?
}
//*/



















/*
global protocol Proto1(role A, role B, role C)
{
	// testing "passing" rename (shadow) map with messages -- also need to test re-receiving rename map with already applied renaming

	1(x:int) from A to B; @(x>3);
	2(y:int) from B to C; @(y>x);  // compacting doesn't terminate -- FIXME: F renaming needs to be done based on K? i.e., also rename x in F(C)?
	//3(z:int) from C to D; @(z>x);  // ... FIXME: but what if C uses x again in upcoming assertions after the renaming? -- hence pass the renaming as a message
			// -- keep a ("one-level"?) rename map? -- cf. rec unfolding with rec-annotation substitution
			// -- no: C can't use x as a sender, not known; but how about as receiver?
			// -- should renamed vars be recorded in K?
	//3(z:int) from B to C; @(z>x);
	do Proto1(A, B, C);
}
//*/




























































// --- ???


/*
global protocol JavaSmtBug(role B, role S) @(x=0);
{
	5() from B to S;	@False;//@(y>0);
	do JavaSmtBug(B, S); @x;  // Cf. AssrtExistsFormula::toJavaSmtFormula comments
}
//*/


/*
global protocol Proto1(role A, role B) @(x=3);
{
	choice at A
	{
		1(int) from A to B;
		do Proto1(A, B); @4;
	}
	or
	{
		2(int) from A to B;
		do Proto1(A, B); @3;
	}	

		//1(y:int) from A to B; @(x=4);

		//1(y:int) from A to B; @((y=4) && (x=y));
		
		//1(y:int) from A to B; @(x=y);


		//do Proto1(A, B); @3;
}
//*/


/*
global protocol Proto1(role A, role B, role C)
{
	choice at A
	{	
		1(int) from A to B;
		4(int) from A to C;
	}
	or
	{
		2(int) from A to B;
		3(int) from A to C;
	}
}
//*/


/*
global protocol Proto1(role A, role B)
{
	choice at A
	{	
		1(x:int) from A to B;
		choice at A
		{
			2(y:int) from A to B;
			do Proto1(A, B);
		}
		or
		{
			3(z:int) from A to B;
		}
	
	}
	or
	{
		2(int) from A to B;
	}
}
//*/

